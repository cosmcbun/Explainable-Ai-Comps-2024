"use strict";(self.webpackChunkxai_carleton_comps_2024=self.webpackChunkxai_carleton_comps_2024||[]).push([[8496],{5868:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>n,metadata:()=>r,toc:()=>c});var a=o(7624),i=o(2172);const n={},s="ResNet",r={id:"Methodology/ResNet",title:"ResNet",description:"This project\u2019s first model of focus is an implementation of the Residual Neural Network (ResNet) architecture, a derivative of the basic convolutional neural network. This network was trained on ImageNet, an extremely common dataset for image classification, and will be used in conjunction with a dataset for tumor classification such as that of Panigrahi (2021) and Sarta (2020). Coined by He et al. (2015), ResNet addresses the issues of neural networks\u2019 degradation, where training and evaluation losses spike and lose predictability as a model\u2019s depth passes a certain point. The proposed solution consists of identity mapping, whereby layers pass their outputs to a mapping function that performs one of two actions: it may shortcut part of the input to be recombined at a deeper layer (discussed in Hochreiter et al., 1997), or it may utilize a nonlinear function which asymptotically approximated the use of multiple linear layers at once (introduced in J\xe9gou et al., 2012). This development allows deep neural networks to have no worse loss than shallow ones of appropriate depth.",source:"@site/docs/Methodology/ResNet.md",sourceDirName:"Methodology",slug:"/Methodology/ResNet",permalink:"/Explainable-Ai-Comps-2024/Methodology/ResNet",draft:!1,unlisted:!1,editUrl:"https://github.com/cosmcbun/Explainable-Ai-Comps-2024/tree/main/Website/XAI-Carleton-Comps-2024/docs/Methodology/ResNet.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"MOOC Dropout Prediction",permalink:"/Explainable-Ai-Comps-2024/Methodology/MOOC"},next:{title:"LIME",permalink:"/Explainable-Ai-Comps-2024/category/lime"}},l={},c=[];function d(e){const t={h1:"h1",p:"p",...(0,i.M)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"resnet",children:"ResNet"}),"\n",(0,a.jsx)(t.p,{children:"This project\u2019s first model of focus is an implementation of the Residual Neural Network (ResNet) architecture, a derivative of the basic convolutional neural network. This network was trained on ImageNet, an extremely common dataset for image classification, and will be used in conjunction with a dataset for tumor classification such as that of Panigrahi (2021) and Sarta (2020). Coined by He et al. (2015), ResNet addresses the issues of neural networks\u2019 degradation, where training and evaluation losses spike and lose predictability as a model\u2019s depth passes a certain point. The proposed solution consists of identity mapping, whereby layers pass their outputs to a mapping function that performs one of two actions: it may shortcut part of the input to be recombined at a deeper layer (discussed in Hochreiter et al., 1997), or it may utilize a nonlinear function which asymptotically approximated the use of multiple linear layers at once (introduced in J\xe9gou et al., 2012). This development allows deep neural networks to have no worse loss than shallow ones of appropriate depth."}),"\n",(0,a.jsx)(t.p,{children:"ResNet showed that model degradation could be overcome, thereby rendering deep neural networks much more feasible and revolutionizing the field. With its proposal came the ability for a model to reliably maintain hundreds and even thousands of layers. The uptick in depth that ResNet caused is exactly what makes it a perfect candidate for analysis \u2014 such complexity is necessarily harder to explain, and will hopefully allow the three methods to highlight specifically their strengths and weaknesses."})]})}function p(e={}){const{wrapper:t}={...(0,i.M)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},2172:(e,t,o)=>{o.d(t,{I:()=>r,M:()=>s});var a=o(1504);const i={},n=a.createContext(i);function s(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);